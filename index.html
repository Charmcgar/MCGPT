<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Block Game with Arrow Look</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 10px;
      height: 10px;
      margin-left: -5px;
      margin-top: -5px;
      background: rgba(255,255,255,0.8);
      border-radius: 50%;
      pointer-events: none;
      z-index: 10;
    }
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: sans-serif;
      z-index: 20;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <p>Use arrow keys to look around (up/down for pitch, left/right for yaw).</p>
    <p>WASD to move, Space to jump.</p>
    <p>Left-click to dig, Right-click to place.</p>
    <p>Press 1-3 to choose block type, E to place, Q to break.</p>
  </div>
  <div id="crosshair"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script>
    // Create scene, camera, and renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0x888888)); // Ambient light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Directional light
    directionalLight.position.set(10, 20, 10); // Make sure the light is positioned above and slightly in front of the scene
    scene.add(directionalLight);

    // Load textures
    const loader = new THREE.TextureLoader();
    const textureUrls = [
      'https://www.cgbookcase.com/textures/grass/grass-2.jpg', // Custom grass texture
      'https://www.cgbookcase.com/textures/water/sea-water-2.jpg', // Custom water texture
      'https://www.cgbookcase.com/textures/dirt/dirt-1.jpg', // Custom dirt texture
      'https://www.cgbookcase.com/textures/stone/stone-1.jpg', // Custom stone texture
      'https://www.cgbookcase.com/textures/sand/sand-1.jpg', // Custom sand texture
      'https://www.cgbookcase.com/textures/wood/wood-2.jpg'  // Custom wood texture
    ];

    let textures = [];
    let texturesLoaded = 0;

    function loadTextures() {
      textureUrls.forEach((url, index) => {
        loader.load(
          url,
          (texture) => {
            textures[index] = texture;
            texturesLoaded++;
            if (texturesLoaded === textureUrls.length) {
              createBlocks(); // Once textures are loaded, create blocks
            }
          },
          undefined,
          (error) => {
            console.error(`Error loading texture: ${url}`, error);
            textures[index] = new THREE.Texture(); // Empty texture as fallback
            texturesLoaded++;
            if (texturesLoaded === textureUrls.length) {
              createBlocks();
            }
          }
        );
      });
    }

    // Block creation
    const blockGeo = new THREE.BoxGeometry(1, 1, 1);
    const blocks = [];
    const worldSize = 16;

    function createBlocks() {
      for (let x = 0; x < worldSize; x++) {
        for (let z = 0; z < worldSize; z++) {
          const block = new THREE.Mesh(blockGeo, new THREE.MeshLambertMaterial({ map: textures[0] }));
          block.position.set(x - worldSize / 2, -1, z - worldSize / 2);
          block.userData.solid = true;
          scene.add(block);
          blocks.push(block);
        }
      }
    }

    // Camera setup
    camera.position.set(0, 2, 5);
    camera.rotation.order = "YXZ"; // yaw then pitch

    // Movement and collision detection
    const keys = {};
    const velocity = new THREE.Vector3();
    const gravity = -0.01;
    let canJump = false;
    const lookSpeed = 0.05; // Increased look speed for smoother camera movement

    // Listen for key events
    document.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;

      // Camera rotation with arrow keys
      if (e.key === "ArrowLeft") {
        camera.rotation.y += lookSpeed;
      }
      if (e.key === "ArrowRight") {
        camera.rotation.y -= lookSpeed;
      }
      if (e.key === "ArrowUp") {
        camera.rotation.x -= lookSpeed;
        camera.rotation.x = Math.max(-Math.PI / 2, camera.rotation.x);
      }
      if (e.key === "ArrowDown") {
        camera.rotation.x += lookSpeed;
        camera.rotation.x = Math.min(Math.PI / 2, camera.rotation.x);
      }

      // Block type selection (keys 1-3)
      if (e.key >= '1' && e.key <= '3') {
        currentBlockType = parseInt(e.key) - 1;
      }

      // E/Q for placing/breaking blocks
      if (e.key === 'e') {
        placeBlock();
      }
      if (e.key === 'q') {
        digBlock();
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Collision detection function
    function checkCollision(position) {
      for (let block of blocks) {
        if (block.userData.solid && position.distanceTo(block.position) < 0.6) {
          return true;
        }
      }
      return false;
    }

    // Update player movement and physics
    function updatePlayer() {
      const moveSpeed = 0.1;
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      direction.y = 0;
      direction.normalize();
      const right = new THREE.Vector3().crossVectors(camera.up, direction).normalize();

      let newPosition = camera.position.clone();
      if (keys['w']) newPosition.addScaledVector(direction, moveSpeed);
      if (keys['s']) newPosition.addScaledVector(direction, -moveSpeed);
      if (keys['a']) newPosition.addScaledVector(right, moveSpeed);
      if (keys['d']) newPosition.addScaledVector(right, -moveSpeed);
      if (!checkCollision(newPosition)) camera.position.copy(newPosition);

      // Jumping
      if (keys[' '] && canJump) {
        velocity.y = 0.2;
        canJump = false;
      }
      velocity.y += gravity;
      camera.position.y += velocity.y;
      if (camera.position.y < 1) {
        camera.position.y = 1;
        velocity.y = 0;
        canJump = true;
      }
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      updatePlayer();
      renderer.render(scene, camera);
    }
    animate();

    // Adjust renderer on window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start loading textures
    loadTextures();
  </script>
</body>
</html>
