<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Block Game with Arrow Look</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 10px;
      height: 10px;
      margin-left: -5px;
      margin-top: -5px;
      background: rgba(255,255,255,0.8);
      border-radius: 50%;
      pointer-events: none;
      z-index: 10;
    }
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: sans-serif;
      z-index: 20;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <p>Use arrow keys to look around (up/down for pitch, left/right for yaw).</p>
    <p>WASD to move, Space to jump.</p>
    <p>Left-click to dig, Right-click to place.</p>
    <p>Press 1-3 to choose block type, E to place, Q to break.</p>
  </div>
  <div id="crosshair"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script>
    // Create scene, camera, and renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0x888888)); // Ambient light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Directional light
    directionalLight.position.set(10, 20, 10); // Make sure the light is positioned above and slightly in front of the scene
    scene.add(directionalLight);

    // Load textures
    const loader = new THREE.TextureLoader();
    const textureUrls = [
      'Grass004_1K-JPG_Color.jpg', // Custom grass texture
      'dirt_2.png'                // Custom dirt texture
    ];

    let textures = [];
    let texturesLoaded = 0;

    function loadTextures() {
      textureUrls.forEach((url, index) => {
        loader.load(
          url,
          (texture) => {
            textures[index] = texture;
            texturesLoaded++;
            if (texturesLoaded === textureUrls.length) {
              createBlocks(); // Once textures are loaded, create blocks
            }
          },
          undefined,
          (error) => {
            console.error(`Error loading texture: ${url}`, error);
            textures[index] = new THREE.Texture(); // Empty texture as fallback
            texturesLoaded++;
            if (texturesLoaded === textureUrls.length) {
              createBlocks();
            }
          }
        );
      });
    }

    // Block creation
    const blockGeo = new THREE.BoxGeometry(1, 1, 1);
    const blocks = [];
    const worldSize = 16;

    function createBlocks() {
      for (let x = 0; x < worldSize; x++) {
        for (let y = 0; y < worldSize; y++) {
          for (let z = 0; z < worldSize; z++) {
            const textureIndex = (x + y + z) % 2; // Alternate between grass and dirt textures
            const block = new THREE.Mesh(blockGeo, new THREE.MeshLambertMaterial({ map: textures[textureIndex] }));
            block.position.set(x - worldSize / 2, y - worldSize / 2, z - worldSize / 2);
            block.userData.solid = true;
            scene.add(block);
            blocks.push(block);
          }
        }
      }
    }

    // Camera setup
    camera.position.set(0, 10, 10);
    camera.rotation.order = "YXZ"; // yaw then pitch

    // Movement and collision detection
    const keys = {};
    const velocity = new THREE.Vector3();
    const gravity = -0.01;
    let canJump = false;
    const lookSpeed = 0.05; // Increased look speed for smoother camera movement
    let currentBlockType = 0; // Default block type

    // Listen for key events
    document.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;

      // Camera rotation with arrow keys
      if (e.key === "ArrowLeft") {
        camera.rotation.y += lookSpeed;
      }
      if (e.key === "ArrowRight") {
        camera.rotation.y -= lookSpeed;
      }
      if (e.key === "ArrowUp") {
        camera.rotation.x -= lookSpeed;
        camera.rotation.x = Math.max(-Math.PI / 2, camera.rotation.x);
      }
      if (e.key === "ArrowDown") {
        camera.rotation.x += lookSpeed;
        camera.rotation.x = Math.min(Math.PI / 2, camera.rotation.x);
      }

      // Block type selection (keys 1-2)
      if (e.key >= '1' && e.key <= '2') {
        currentBlockType = parseInt(e.key) - 1;
      }

      // E/Q for placing/breaking blocks
      if (e.key === 'e') {
        placeBlock();
      }
      if (e.key === 'q') {
        digBlock();
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Collision detection function
    function checkCollision(position) {
      for (let block of blocks) {
        if (block.userData.solid && position.distanceTo(block.position) < 0.6) {
          return true;
        }
      }
      return false;
    }

    // Block placement function
    function placeBlock() {
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      const position = camera.position.clone().add(direction.multiplyScalar(1.5));
      const block = new THREE.Mesh(blockGeo, new THREE.MeshLambertMaterial({ map: textures[currentBlockType] }));
      block.position.copy(position);
      block.userData.solid = true;
      scene.add(block);
      blocks.push(block);
    }

    // Block digging function
    function digBlock() {
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      const raycaster = new THREE.Raycaster(camera.position, direction);
      const intersects = raycaster.intersectObjects(blocks);
      if (intersects.length > 0) {
        const intersected = intersects[0].object;
        scene.remove(intersected);
        blocks.splice(blocks.indexOf(intersected), 1);
      }
    }

    // Update player movement and physics
    function updatePlayer() {
      const moveSpeed = 0.1;
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      direction.y = 0;
      direction.normalize();
      const right = new THREE.Vector3().crossVectors(camera.up, direction).normalize();

      let newPosition = camera.position.clone();
      if (keys['w']) newPosition.addScaledVector(direction, moveSpeed);
      if (keys['s']) newPosition.addScaledVector(direction, -moveSpeed);
      if (keys['a']) newPosition.addScaledVector(right, moveSpeed);
      if (keys['d']) newPosition.addScaledVector(right, -moveSpeed);
      if (!checkCollision(newPosition)) camera.position.copy(newPosition);

      // Jumping
      if (keys[' '] && canJump) {
        velocity.y = 0.2;
        canJump = false;
      }
      velocity.y += gravity;
      camera.position.y += velocity.y;
      if (camera.position.y < 1) {
        camera.position.y = 1;
        velocity.y = 0;
        canJump = true;
      }
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      updatePlayer();
      renderer.render(scene, camera);
    }
    animate();

    // Adjust renderer on window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start loading textures
    loadTextures();
  </script>
</body>
</html>
